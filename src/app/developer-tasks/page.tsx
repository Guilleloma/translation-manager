'use client';

import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Container,
  Heading,
  Text,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  Badge,
  Button,
  Select,
  Input,
  useToast,
  Flex,
  Spacer,
  HStack,
  Card,
  CardBody,
  CardHeader,
  Divider,
  InputGroup,
  InputLeftElement,
  IconButton,
  useDisclosure,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  useColorModeValue,
  VStack,
  Alert,
  AlertIcon,
  AlertTitle,
  AlertDescription,
  Stat,
  StatLabel,
  StatNumber,
  StatHelpText,
  Grid,
  GridItem
} from '@chakra-ui/react';
import { SearchIcon, EditIcon, CheckIcon, CloseIcon } from '@chakra-ui/icons';
import { useUser } from '../../context/UserContext';
import { Copy } from '../../types/copy';

interface AutoGeneratedCopy extends Copy {
  isAutoGenerated: boolean;
  suggestedSlug?: string;
  spanishText?: string; // Texto en espa√±ol para mostrar siempre
  affectedLanguages?: string[];
  totalTranslations?: number;
  originalSlug?: string; // Slug original para la actualizaci√≥n
  originalCopyIds?: string[]; // IDs originales de los copys
}

/**
 * P√°gina de tareas para developers
 * Muestra los textos que necesitan revisi√≥n de slugs auto-generados
 */
export default function DeveloperTasks() {
  const { currentUser } = useUser();
  const toast = useToast();
  
  const [autoGeneratedCopies, setAutoGeneratedCopies] = useState<AutoGeneratedCopy[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedLanguage, setSelectedLanguage] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  
  // Estado para manejar la edici√≥n de cada elemento individualmente
  const [editingItems, setEditingItems] = useState<Record<string, string>>({});
  
  const [stats, setStats] = useState({
    total: 0,
    byLanguage: {} as Record<string, number>
  });

  const { isOpen, onOpen, onClose } = useDisclosure();
  const [selectedCopy, setSelectedCopy] = useState<AutoGeneratedCopy | null>(null);

  const languages = [
    { code: 'all', name: 'Todos los idiomas' },
    { code: 'es', name: 'Espa√±ol' },
    { code: 'en', name: 'English' },
    { code: 'fr', name: 'Fran√ßais' },
    { code: 'de', name: 'Deutsch' },
    { code: 'it', name: 'Italiano' },
    { code: 'pt', name: 'Portugu√™s' }
  ];

  // Funci√≥n para detectar si un slug es auto-generado
  const isSlugAutoGenerated = useCallback((slug: string, text: string, metadata?: any): boolean => {
    // Si el slug ha sido revisado manualmente, ya no se considera auto-generado
    if (metadata?.manuallyReviewed) {
      return false;
    }
    
    const autoPatterns = [
      /^auto_/,
      /^text_\d+/,
      /\d{10,}/,  // timestamps
      /^[a-z]+_\d+$/,
      /^copy_\d+$/
    ];

    return autoPatterns.some(pattern => pattern.test(slug));
  }, []);

  // Funci√≥n para generar sugerencia de slug basada en el texto
  const generateSuggestedSlug = useCallback((text: string): string => {
    return text
      .toLowerCase()
      .replace(/[√°√†√§√¢]/g, 'a')
      .replace(/[√©√®√´√™]/g, 'e')
      .replace(/[√≠√¨√Ø√Æ]/g, 'i')
      .replace(/[√≥√≤√∂√¥]/g, 'o')
      .replace(/[√∫√π√º√ª]/g, 'u')
      .replace(/[√±]/g, 'n')
      .replace(/[^a-z0-9\s]/g, '')
      .trim()
      .split(/\s+/)
      .slice(0, 3)
      .join('_');
  }, []);

  /**
   * Funci√≥n para cargar los copys que necesitan revisi√≥n de slug
   * Implementada con useCallback para mantenerla estable entre renderizados
   * y evitar ciclos infinitos cuando se usa como dependencia en useEffect
   */
  const fetchAutoGeneratedCopies = useCallback(async () => {
    try {
      // Verificar si el usuario sigue autenticado antes de hacer la petici√≥n
      if (!currentUser) {
        console.log('üîß Developer Tasks: Usuario no autenticado, no se cargar√°n los datos');
        return;
      }

      setLoading(true);
      console.log('üîß Developer Tasks: Obteniendo copys que necesitan revisi√≥n de slug...');
      
      // Agregar un query param para obtener solo los copys que necesitan revisi√≥n
      const response = await fetch('/api/copys?needsSlugReview=true', {
        // A√±adir cabeceras para evitar problemas de cach√©
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error HTTP: ${response.status}`);
      }
      
      const data = await response.json();
      
      console.log(`üîß Developer Tasks: Obtenidos ${data.data?.length || 0} copys que necesitan revisi√≥n`);
      
      if (data.success && Array.isArray(data.data)) {
        // Agrupar copys por slug para trabajar con ellos independientemente del idioma
        const slugGroups: Record<string, Copy[]> = {};
        
        // Primero agrupamos todos los copys por slug
        data.data.forEach((copy: Copy) => {
          // Asegurarnos de que el copy tiene la propiedad needsSlugReview a true
          if (copy.needsSlugReview) {
            if (!slugGroups[copy.slug]) {
              slugGroups[copy.slug] = [];
            }
            slugGroups[copy.slug].push(copy);
          }
        });
        
        console.log(`üîß Developer Tasks: Agrupados ${Object.keys(slugGroups).length} slugs √∫nicos`);
        
        // Procesamos los grupos, priorizando el texto en espa√±ol como referencia
        const autoGenerated = Object.entries(slugGroups).map(([slug, copies], index) => {
          // Buscar primero la versi√≥n en espa√±ol
          const spanishCopy = copies.find(c => c.language === 'es');
          // Si no hay versi√≥n en espa√±ol, usar la primera disponible
          const referenceCopy = spanishCopy || copies[0];
          
          return {
            ...referenceCopy,
            // Crear un ID √∫nico para cada grupo de slug
            _id: `slug_group_${index}_${slug}`,
            isAutoGenerated: true,
            suggestedSlug: generateSuggestedSlug(referenceCopy.text),
            spanishText: spanishCopy ? spanishCopy.text : 'No disponible en espa√±ol',
            affectedLanguages: copies.map(c => c.language),
            totalTranslations: copies.length,
            originalSlug: slug, // Guardamos el slug original para la actualizaci√≥n
            originalCopyIds: copies.map(c => c._id) // Guardamos los IDs originales
          };
        });
        
        setAutoGeneratedCopies(autoGenerated);
        
        // Calcular estad√≠sticas de slugs √∫nicos
        setStats({
          total: autoGenerated.length,
          byLanguage: {}
        });
        
        console.log(`üîß Developer: Encontrados ${autoGenerated.length} slugs auto-generados`);
      } else {
        console.error('‚ùå Error: Respuesta de API inv√°lida o sin datos');
        setAutoGeneratedCopies([]);
        setStats({ total: 0, byLanguage: {} });
        
        // Solo mostrar error si el usuario sigue autenticado
        if (currentUser) {
          toast({
            title: 'Error',
            description: 'No se pudieron cargar los datos',
            status: 'error',
            duration: 3000,
            isClosable: true,
          });
        }
      }
    } catch (error) {
      console.error('‚ùå Error fetching auto-generated copies:', error);
      setAutoGeneratedCopies([]);
      setStats({ total: 0, byLanguage: {} });
      
      // Solo mostrar error si el usuario sigue autenticado
      if (currentUser) {
        toast({
          title: 'Error de conexi√≥n',
          description: 'No se pudo conectar con el servidor',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
      }
    } finally {
      setLoading(false);
    }
  }, [currentUser, toast, generateSuggestedSlug]);

  const handleUpdateSlug = useCallback(async (copyId: string, oldSlug: string) => {
    const newSlugValue = editingItems[copyId];
    
    if (!newSlugValue || !newSlugValue.trim()) {
      toast({
        title: 'Error',
        description: 'El slug no puede estar vac√≠o',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    try {
      // Buscar el copy en la lista para obtener el slug original
      const copyToUpdate = autoGeneratedCopies.find(copy => copy._id === copyId);
      if (!copyToUpdate || !copyToUpdate.originalSlug) {
        console.error(`üõë No se encontr√≥ el copy con ID ${copyId} o no tiene originalSlug`);
        return;
      }
      
      console.log(`üîß Actualizando slug ${copyToUpdate.originalSlug} a ${newSlugValue}`);
      
      // Actualizar el slug en todos los idiomas usando el slug original
      // y marcarlo como revisado manualmente para que no aparezca en la lista
      console.log(`üîß Actualizando slug ${copyToUpdate.originalSlug} a ${newSlugValue} y marc√°ndolo como revisado manualmente`);
      
      const response = await fetch(`/api/copys/${copyToUpdate.originalSlug}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          slug: newSlugValue.trim(),
          updateAllLanguages: true, // Indicar que se actualice en todos los idiomas
          metadata: { 
            manuallyReviewed: true, // Marcar como revisado manualmente
            reviewedAt: new Date().toISOString(),
            reviewedBy: currentUser?.id || 'unknown'
          }
        }),
      });

      const data = await response.json();
      
      if (data.success) {
        // Limpiar el estado de edici√≥n
        setEditingItems(prev => {
          const newState = {...prev};
          delete newState[copyId];
          return newState;
        });
        
        toast({
          title: '√âxito',
          description: 'El slug ha sido actualizado',
          status: 'success',
          duration: 3000,
          isClosable: true,
        });
        
        // Refrescar datos inmediatamente
        console.log('üîÑ Refrescando lista de slugs auto-generados...');
        
        // Esperamos un breve momento para asegurar que los cambios se han propagado
        setTimeout(() => {
          fetchAutoGeneratedCopies();
        }, 500);
        
        // Configurar un segundo refresco despu√©s de un poco m√°s de tiempo
        // para asegurar que los cambios se reflejan completamente
        setTimeout(() => {
          console.log('üîÑ Refresco secundario de la lista...');
          fetchAutoGeneratedCopies();
        }, 2000);
      } else {
        toast({
          title: 'Error',
          description: data.error || 'Error al actualizar el slug',
          status: 'error',
          duration: 3000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('Error updating slug:', error);
      toast({
        title: 'Error',
        description: 'Error al actualizar el slug',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  }, [autoGeneratedCopies, currentUser, editingItems, toast, fetchAutoGeneratedCopies]);

  const startEditing = useCallback((copyId: string, currentSlug: string) => {
    setEditingItems(prev => ({
      ...prev,
      [copyId]: currentSlug
    }));
  }, []);

  const cancelEditing = useCallback((copyId: string) => {
    setEditingItems(prev => {
      const newState = {...prev};
      delete newState[copyId];
      return newState;
    });
  }, []);

  const openCopyDetails = useCallback((copy: AutoGeneratedCopy) => {
    setSelectedCopy(copy);
    onOpen();
  }, [onOpen]);

  // Efecto para cargar los datos iniciales cuando se abre la p√°gina o cambia el usuario
  useEffect(() => {
    // Solo cargar datos si hay un usuario autenticado
    if (currentUser) {
      console.log('üîó Cargando lista de copys que necesitan revisi√≥n de slug...');
      fetchAutoGeneratedCopies();
    }
  }, [currentUser, fetchAutoGeneratedCopies]);
  
  // Efecto para escuchar eventos de actualizaci√≥n de copys
  useEffect(() => {
    // Funci√≥n para refrescar datos cuando haya cambios generales en la aplicaci√≥n
    const handleCopysChange = () => {
      console.log('üì¢ Detectado evento copysUpdated, actualizando tareas de developer...');
      // Solo ejecutar si el usuario est√° autenticado para evitar p√©rdida de sesi√≥n
      if (currentUser) {
        fetchAutoGeneratedCopies();
      }
    };
    
    // Funci√≥n para manejar espec√≠ficamente la creaci√≥n de nuevos copys
    const handleNewCopy = (event: CustomEvent) => {
      console.log('üéâ Detectado evento newCopyCreated, nuevo copy creado!');
      console.log('üîß Detalles del nuevo copy:', event.detail);
      
      // Solo ejecutar si el usuario est√° autenticado
      if (currentUser) {
        // Refrescar la lista inmediatamente
        fetchAutoGeneratedCopies();
        
        // Mostrar notificaci√≥n al usuario sobre el nuevo copy
        toast({
          title: 'Nuevo copy creado',
          description: 'Se ha detectado un nuevo copy que necesita revisi√≥n de slug',
          status: 'success',
          duration: 3000,
          isClosable: true,
        });
      }
    };
    
    // Suscribirse a ambos eventos
    window.addEventListener('copysUpdated', handleCopysChange);
    window.addEventListener('newCopyCreated', handleNewCopy as EventListener);
    
    // Limpiar los listeners cuando el componente se desmonta
    return () => {
      window.removeEventListener('copysUpdated', handleCopysChange);
      window.removeEventListener('newCopyCreated', handleNewCopy as EventListener);
    };
  }, [currentUser, toast, fetchAutoGeneratedCopies]);

  // Filtrar copys solo por b√∫squeda (ya no filtramos por idioma)
  const filteredCopies = autoGeneratedCopies.filter(copy => {
    const matchesSearch = searchTerm === '' || 
      copy.text.toLowerCase().includes(searchTerm.toLowerCase()) ||
      copy.slug.toLowerCase().includes(searchTerm.toLowerCase());
    
    return matchesSearch;
  });

  if (loading) {
    return (
      <Container maxW="container.xl" py={8}>
        <Box textAlign="center">
          <Text>Cargando tareas de developer...</Text>
        </Box>
      </Container>
    );
  }

  return (
    <Container maxW="container.xl" py={8}>
      {/* Header */}
      <Flex mb={8} alignItems="center" justifyContent="space-between">
        <Box>
          <Heading size="lg" mb={2}>
            üîß Mis Tareas de Developer
          </Heading>
          <Text color="gray.600">
            Gestiona los textos que necesitan slugs m√°s descriptivos
          </Text>
        </Box>
        {/* Bot√≥n de refrescar manteniendo la sesi√≥n */}
        <IconButton
          aria-label="Refrescar lista"
          icon={<span role="img" aria-label="refresh">üîÑ</span>}
          colorScheme="blue"
          onClick={() => {
            // Verificar que el usuario sigue autenticado
            if (currentUser) {
              console.log('üîÑ Refrescando manualmente la lista de slugs...');
              fetchAutoGeneratedCopies();
              toast({
                title: 'Lista actualizada',
                description: 'Se han cargado los √∫ltimos copys que necesitan revisi√≥n',
                status: 'info',
                duration: 2000,
                isClosable: true,
              });
            } else {
              console.error('‚ùå Error: Usuario no autenticado');
              toast({
                title: 'Error',
                description: 'Debe iniciar sesi√≥n para actualizar la lista',
                status: 'error',
                duration: 2000,
                isClosable: true,
              });
            }
          }}
        />
      </Flex>

      {/* Estad√≠sticas */}
      <Grid templateColumns="repeat(auto-fit, minmax(200px, 1fr))" gap={4} mb={6}>
        <Card>
          <CardBody>
            <Stat>
              <StatLabel>Total de slugs auto-generados</StatLabel>
              <StatNumber>{stats.total}</StatNumber>
              <StatHelpText>Requieren revisi√≥n</StatHelpText>
            </Stat>
          </CardBody>
        </Card>
      </Grid>

      {/* Recomendaciones para slugs i18n */}
      <Alert status="info" mb={6}>
        <AlertIcon />
        <Box>
          <AlertTitle>üí° Recomendaciones para slugs compatibles con i18n</AlertTitle>
          <AlertDescription>
            <VStack align="start" spacing={2} mt={2}>
              <Text>‚Ä¢ <strong>Usa ingl√©s:</strong> Los slugs deben estar en ingl√©s para ser universales</Text>
              <Text>‚Ä¢ <strong>S√© descriptivo:</strong> Usa palabras que describan el contenido (ej: "welcome_message", "error_validation")</Text>
              <Text>‚Ä¢ <strong>Estructura jer√°rquica:</strong> Usa guiones bajos para agrupar (ej: "auth_login_title", "auth_login_button")</Text>
              <Text>‚Ä¢ <strong>Evita caracteres especiales:</strong> Solo letras, n√∫meros y guiones bajos</Text>
              <Text>‚Ä¢ <strong>Mant√©n consistencia:</strong> Usa el mismo patr√≥n en toda la aplicaci√≥n</Text>
            </VStack>
          </AlertDescription>
        </Box>
      </Alert>

      {/* Filtros */}
      <Flex mb={4} flexWrap={["wrap", "nowrap"]}>
        <InputGroup maxW="400px" mr={4} mb={[4, 0]}>
          <InputLeftElement pointerEvents="none">
            <SearchIcon color="gray.300" />
          </InputLeftElement>
          <Input 
            placeholder="Buscar por texto o slug"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </InputGroup>
      </Flex>

      {/* Tabla de slugs que necesitan revisi√≥n */}
      {filteredCopies.length > 0 ? (
        <Table variant="simple" mt={4}>
          <Thead>
            <Tr>
              <Th>Texto original</Th>
              <Th>Slug actual</Th>
              <Th>Sugerencia</Th>
              <Th>Idiomas</Th>
              <Th width="150px">Acciones</Th>
            </Tr>
          </Thead>
          <Tbody>
            {filteredCopies.map((copy) => (
              <Tr key={copy._id}>
                <Td maxW="250px" isTruncated>
                  <Text fontWeight="medium">
                    {copy.spanishText || copy.text}
                  </Text>
                </Td>
                <Td maxW="200px" isTruncated>
                  {editingItems[copy._id] !== undefined ? (
                    <InputGroup size="sm">
                      <Input
                        value={editingItems[copy._id]}
                        onChange={(e) => {
                          setEditingItems(prev => ({
                            ...prev,
                            [copy._id]: e.target.value
                          }));
                        }}
                        placeholder="Nuevo slug"
                      />
                    </InputGroup>
                  ) : (
                    <Text fontFamily="monospace" color="orange.500">
                      {copy.originalSlug}
                    </Text>
                  )}
                </Td>
                <Td maxW="200px" isTruncated>
                  <Text fontFamily="monospace" color="green.500">
                    {copy.suggestedSlug}
                  </Text>
                </Td>
                <Td>
                  <HStack spacing={1}>
                    {copy.affectedLanguages?.map((lang) => (
                      <Badge key={lang} colorScheme="blue" size="sm">
                        {lang}
                      </Badge>
                    ))}
                  </HStack>
                </Td>
                <Td>
                  {editingItems[copy._id] !== undefined ? (
                    <HStack spacing={2}>
                      <IconButton
                        aria-label="Guardar cambios"
                        icon={<CheckIcon />}
                        size="sm"
                        colorScheme="green"
                        onClick={() => handleUpdateSlug(copy._id, copy.originalSlug || '')}
                      />
                      <IconButton
                        aria-label="Cancelar edici√≥n"
                        icon={<CloseIcon />}
                        size="sm"
                        colorScheme="red"
                        variant="outline"
                        onClick={() => cancelEditing(copy._id)}
                      />
                    </HStack>
                  ) : (
                    <HStack spacing={2}>
                      <Button
                        size="sm"
                        leftIcon={<EditIcon />}
                        colorScheme="blue"
                        variant="outline"
                        onClick={() => startEditing(copy._id, copy.originalSlug || '')}
                      >
                        Editar
                      </Button>
                    </HStack>
                  )}
                </Td>
              </Tr>
            ))}
          </Tbody>
        </Table>
      ) : (
        <Box textAlign="center" p={8} borderWidth="1px" borderRadius="lg">
          <Heading size="md" mb={2} color="gray.500">No hay slugs por revisar</Heading>
          <Text>Todos los slugs han sido revisados o a√∫n no se han creado copys que requieran revisi√≥n.</Text>
        </Box>
      )}

      {/* Modal de detalles del copy */}
      <Modal isOpen={isOpen} onClose={onClose} size="xl">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Detalles del Copy</ModalHeader>
          <ModalCloseButton />
          <ModalBody>
            {selectedCopy && (
              <Box>
                <Heading size="sm" mb={2}>Texto Original</Heading>
                <Text mb={4}>{selectedCopy.text}</Text>
                
                <Heading size="sm" mb={2}>Slug Actual</Heading>
                <Text fontFamily="monospace" mb={4}>{selectedCopy.originalSlug}</Text>
                
                <Heading size="sm" mb={2}>Slug Sugerido</Heading>
                <Text fontFamily="monospace" color="green.500" mb={4}>{selectedCopy.suggestedSlug}</Text>
                
                <Heading size="sm" mb={2}>Idiomas Afectados</Heading>
                <HStack spacing={2} mb={4}>
                  {selectedCopy.affectedLanguages?.map(lang => (
                    <Badge key={lang} colorScheme="blue">{lang}</Badge>
                  ))}
                </HStack>
                
                <Heading size="sm" mb={2}>ID Original</Heading>
                <Text fontFamily="monospace" fontSize="sm" mb={4}>{selectedCopy._id}</Text>
              </Box>
            )}
          </ModalBody>
          <ModalFooter>
            <Button variant="ghost" mr={3} onClick={onClose}>
              Cerrar
            </Button>
            {selectedCopy && (
              <Button 
                colorScheme="blue" 
                onClick={() => {
                  onClose();
                  startEditing(selectedCopy._id, selectedCopy.originalSlug || '');
                }}
              >
                Editar Slug
              </Button>
            )}
          </ModalFooter>
        </ModalContent>
      </Modal>
    </Container>
  );
}
