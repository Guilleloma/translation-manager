'use client';

import React, { useState, useEffect, useCallback } from 'react';
import {
  Box,
  Container,
  Heading,
  Text,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  Badge,
  Button,
  Select,
  Input,
  useToast,
  Flex,
  Spacer,
  HStack,
  Card,
  CardBody,
  CardHeader,
  Divider,
  InputGroup,
  InputLeftElement,
  IconButton,
  useDisclosure,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  useColorModeValue,
  VStack,
  Alert,
  AlertIcon,
  AlertTitle,
  AlertDescription,
  Stat,
  StatLabel,
  StatNumber,
  StatHelpText,
  Grid,
  GridItem
} from '@chakra-ui/react';
import { SearchIcon, EditIcon, CheckIcon, CloseIcon } from '@chakra-ui/icons';
import { useUser } from '../../context/UserContext';
import { Copy } from '../../types/copy';
import dataService from '../../services/dataService';

interface AutoGeneratedCopy extends Copy {
  isAutoGenerated: boolean;
  suggestedSlug?: string;
  spanishText?: string; // Texto en espa√±ol para mostrar siempre
  affectedLanguages?: string[];
  totalTranslations?: number;
  originalSlug?: string; // Slug original para la actualizaci√≥n
  originalCopyIds?: string[]; // IDs originales de los copys
}

/**
 * P√°gina de tareas para developers
 * Muestra los textos que necesitan revisi√≥n de slugs auto-generados
 */
export default function DeveloperTasks() {
  const { currentUser } = useUser();
  const toast = useToast();
  
  const [autoGeneratedCopies, setAutoGeneratedCopies] = useState<AutoGeneratedCopy[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedLanguage, setSelectedLanguage] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  
  // Estado para manejar la edici√≥n de cada elemento individualmente
  const [editingItems, setEditingItems] = useState<Record<string, string>>({});
  
  const [stats, setStats] = useState({
    total: 0,
    byLanguage: {} as Record<string, number>
  });

  const { isOpen, onOpen, onClose } = useDisclosure();
  const [selectedCopy, setSelectedCopy] = useState<AutoGeneratedCopy | null>(null);

  const languages = [
    { code: 'all', name: 'Todos los idiomas' },
    { code: 'es', name: 'Espa√±ol' },
    { code: 'en', name: 'English' },
    { code: 'fr', name: 'Fran√ßais' },
    { code: 'de', name: 'Deutsch' },
    { code: 'it', name: 'Italiano' },
    { code: 'pt', name: 'Portugu√™s' }
  ];

  // Funci√≥n para detectar si un slug es auto-generado
  const isSlugAutoGenerated = useCallback((slug: string, text: string, metadata?: any): boolean => {
    // Si el slug ha sido revisado manualmente, ya no se considera auto-generado
    if (metadata?.manuallyReviewed) {
      return false;
    }
    
    const autoPatterns = [
      /^auto_/,
      /^text_\d+/,
      /\d{10,}/,  // timestamps
      /^[a-z]+_\d+$/,
      /^copy_\d+$/
    ];

    return autoPatterns.some(pattern => pattern.test(slug));
  }, []);

  // Funci√≥n para generar sugerencia de slug basada en el texto
  const generateSuggestedSlug = useCallback((text: string): string => {
    return text
      .toLowerCase()
      .replace(/[√°√†√§√¢]/g, 'a')
      .replace(/[√©√®√´√™]/g, 'e')
      .replace(/[√≠√¨√Ø√Æ]/g, 'i')
      .replace(/[√≥√≤√∂√¥]/g, 'o')
      .replace(/[√∫√π√º√ª]/g, 'u')
      .replace(/[√±]/g, 'n')
      .replace(/[^a-z0-9\s]/g, '')
      .trim()
      .split(/\s+/)
      .slice(0, 3)
      .join('_');
  }, []);

  /**
   * Funci√≥n para cargar los copys que necesitan revisi√≥n de slug
   * Implementada con useCallback para mantenerla estable entre renderizados
   * y evitar ciclos infinitos cuando se usa como dependencia en useEffect
   */
  const fetchAutoGeneratedCopies = useCallback(async () => {
    console.log('üîÑ ===== FETCHAUTOGENERATEDCOPIES - INICIO =====');
    
    try {
      // Verificar si el usuario sigue autenticado antes de hacer la petici√≥n
      if (!currentUser) {
        console.log('üîß Developer Tasks: Usuario no autenticado, no se cargar√°n los datos');
        return;
      }

      setLoading(true);
      console.log('üì° Haciendo petici√≥n a /api/copys...');
      
      const response = await fetch('/api/copys?needsSlugReview=true', {
        // A√±adir cabeceras para evitar problemas de cach√©
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      
      if (!response.ok) {
        throw new Error(`Error HTTP: ${response.status}`);
      }
      
      const data = await response.json();
      
      console.log('üì• RESPUESTA DE API /api/copys:', {
        success: data.success,
        totalCopys: data.data?.length || 0,
        error: data.error
      });

      if (data.success && Array.isArray(data.data)) {
        // Agrupar copys por slug para trabajar con ellos independientemente del idioma
        const slugGroups: Record<string, Copy[]> = {};
        
        // Primero agrupamos todos los copys por slug
        data.data.forEach((copy: Copy) => {
          // Asegurarnos de que el copy tiene la propiedad needsSlugReview a true
          if (copy.needsSlugReview) {
            if (!slugGroups[copy.slug]) {
              slugGroups[copy.slug] = [];
            }
            slugGroups[copy.slug].push(copy);
          }
        });
        
        console.log(`üìä AN√ÅLISIS DE COPYS PARA REVISI√ìN:`);
        console.log('Total copys en BD:', data.data.length);
        console.log('Necesitan revisi√≥n de slug:', Object.keys(slugGroups).length);
        
        if (Object.keys(slugGroups).length > 0) {
          // Verificar grupos de traducci√≥n
          const withGroups = data.data.filter(copy => copy.translationGroupId);
          const withoutGroups = data.data.filter(copy => !copy.translationGroupId);
          console.log('Con grupo de traducci√≥n:', withGroups.length);
          console.log('Sin grupo de traducci√≥n:', withoutGroups.length);
          
          // Mostrar algunos ejemplos
          console.log('üìã PRIMEROS 5 COPYS QUE NECESITAN REVISI√ìN:', data.data.slice(0, 5).map(c => ({
            id: c.id,
            slug: c.slug,
            language: c.language,
            text: c.text.substring(0, 30) + '...',
            groupId: c.translationGroupId,
            isOriginal: c.isOriginalText
          })));
          
          // Verificar si hay grupos con m√∫ltiples traducciones
          if (withGroups.length > 0) {
            const groupsMap: Record<string, any[]> = withGroups.reduce((acc, copy) => {
              const groupId = copy.translationGroupId;
              if (groupId && !acc[groupId]) {
                acc[groupId] = [];
              }
              if (groupId) {
                acc[groupId].push({
                  id: copy.id,
                  slug: copy.slug,
                  language: copy.language
                });
              }
              return acc;
            }, {} as Record<string, any[]>);
            
            console.log('üìã GRUPOS CON M√öLTIPLES TRADUCCIONES:');
            Object.entries(groupsMap).forEach(([groupId, copies]) => {
              if (copies.length > 1) {
                console.log(`Grupo ${groupId} (${copies.length} traducciones):`, copies);
              }
            });
          }
        }
        
        // Procesamos los grupos, priorizando el texto en espa√±ol como referencia
        const autoGenerated = Object.entries(slugGroups).map(([slug, copies], index) => {
          // Buscar primero la versi√≥n en espa√±ol
          const spanishCopy = copies.find(c => c.language === 'es');
          // Si no hay versi√≥n en espa√±ol, usar la primera disponible
          const referenceCopy = spanishCopy || copies[0];
          
          const groupData = {
            ...referenceCopy,
            // Crear un ID √∫nico para cada grupo de slug
            _id: `slug_group_${index}_${slug}`,
            isAutoGenerated: true,
            suggestedSlug: generateSuggestedSlug(referenceCopy.text),
            spanishText: spanishCopy ? spanishCopy.text : 'No disponible en espa√±ol',
            affectedLanguages: copies.map(c => c.language),
            totalTranslations: copies.length,
            originalSlug: slug, // Guardamos el slug original para la actualizaci√≥n
            originalCopyIds: copies.map(c => c.id || c._id).filter(Boolean) // Guardamos los IDs originales (usar id o _id)
          };
          
          // Debug: log para el primer grupo
          if (index === 0) {
            console.log('üîç PRIMER GRUPO CREADO (ejemplo):', {
              groupId: groupData._id,
              originalSlug: slug,
              copiesCount: copies.length,
              originalCopyIds: groupData.originalCopyIds,
              sampleCopyStructure: copies[0] ? {
                hasId: !!copies[0].id,
                has_id: !!copies[0]._id,
                id: copies[0].id,
                _id: copies[0]._id
              } : null
            });
          }
          
          return groupData;
        });
        
        console.log('üìä RESUMEN DE GRUPOS CREADOS:', {
          totalGroups: autoGenerated.length,
          groupsWithValidIds: autoGenerated.filter(g => g.originalCopyIds.length > 0).length,
          groupsWithoutIds: autoGenerated.filter(g => g.originalCopyIds.length === 0).length
        });
        
        setAutoGeneratedCopies(autoGenerated);
        
        // Calcular estad√≠sticas de slugs √∫nicos
        setStats({
          total: autoGenerated.length,
          byLanguage: {}
        });
        
        console.log(`üîß Developer: Encontrados ${autoGenerated.length} slugs auto-generados`);
      } else {
        console.error('‚ùå Error: Respuesta de API inv√°lida o sin datos');
        setAutoGeneratedCopies([]);
        setStats({ total: 0, byLanguage: {} });
        
        // Solo mostrar error si el usuario sigue autenticado
        if (currentUser) {
          toast({
            title: 'Error',
            description: 'No se pudieron cargar los datos',
            status: 'error',
            duration: 3000,
            isClosable: true,
          });
        }
      }
    } catch (error) {
      console.error('‚ùå Error fetching auto-generated copies:', error);
      setAutoGeneratedCopies([]);
      setStats({ total: 0, byLanguage: {} });
      
      // Solo mostrar error si el usuario sigue autenticado
      if (currentUser) {
        toast({
          title: "Error de conexi√≥n",
          description: "No se pudo conectar con el servidor",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
      }
    } finally {
      setLoading(false);
      console.log('üîÑ ===== FETCHAUTOGENERATEDCOPIES - FIN =====');
    }
  }, [currentUser, toast, generateSuggestedSlug]);

  // Funci√≥n para actualizar el slug de un copy espec√≠fico
  const handleSlugUpdate = useCallback(async (copyId: string) => {
    console.log('üîÑ ===== HANDLESLUGUPDATE - INICIO =====');
    console.log('üîß Actualizando slug para copy:', copyId);
    
    const newSlugValue = editingItems[copyId];
    
    console.log('üìù DATOS DE ENTRADA:', {
      copyId,
      newSlugValue,
      hasNewSlug: !!newSlugValue?.trim(),
      editingItemsKeys: Object.keys(editingItems)
    });
    
    if (!newSlugValue || !newSlugValue.trim()) {
      console.warn('‚ö†Ô∏è Slug vac√≠o o inv√°lido');
      toast({
        title: "Error",
        description: "El slug no puede estar vac√≠o",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    if (!currentUser) {
      console.error('‚ùå Usuario no autenticado');
      toast({
        title: "Error de autenticaci√≥n",
        description: "Debes estar autenticado para actualizar slugs",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
      return;
    }

    try {
      console.log('üîç Buscando copy en autoGeneratedCopies...');
      
      // Encontrar el copy que se est√° editando
      const copyToUpdate = autoGeneratedCopies.find(copy => copy._id === copyId);
      
      if (!copyToUpdate) {
        console.error('‚ùå Copy no encontrado en autoGeneratedCopies:', copyId);
        console.log('üìã IDs disponibles en autoGeneratedCopies:', autoGeneratedCopies.map(c => c._id));
        toast({
          title: "Error",
          description: "Copy no encontrado",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
        return;
      }
      
      console.log('üìã COPY ENCONTRADO:', {
        id: copyToUpdate.id,
        currentSlug: copyToUpdate.slug,
        newSlug: newSlugValue.trim(),
        language: copyToUpdate.language,
        groupId: copyToUpdate.translationGroupId,
        isOriginal: copyToUpdate.isOriginalText,
        needsReview: copyToUpdate.needsSlugReview,
        originalCopyIds: copyToUpdate.originalCopyIds
      });

      // Usar el primer ID real del copy en lugar del ID de agrupaci√≥n
      const realCopyId = copyToUpdate.originalCopyIds?.[0];
      
      console.log('üîç VALIDANDO IDs REALES:', {
        originalCopyIds: copyToUpdate.originalCopyIds,
        firstId: realCopyId,
        idsLength: copyToUpdate.originalCopyIds?.length || 0,
        allIds: copyToUpdate.originalCopyIds
      });
      
      if (!realCopyId) {
        console.error('‚ùå No se encontr√≥ ID real del copy');
        console.error('üìã Estructura del copy:', copyToUpdate);
        toast({
          title: "Error",
          description: "No se encontr√≥ el ID real del copy. Revisa la consola para m√°s detalles.",
          status: "error",
          duration: 5000,
          isClosable: true,
        });
        return;
      }

      console.log('üì° Haciendo petici√≥n PATCH a API...');
      console.log('üîó Usando ID real del copy:', realCopyId);
      
      // Hacer la petici√≥n de actualizaci√≥n
      const response = await fetch(`/api/copys/${realCopyId}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          slug: newSlugValue.trim(),
          needsSlugReview: false, // Marcar como revisado
          reviewedBy: currentUser.email,
          reviewedAt: new Date().toISOString(),
          updateAllLanguages: true // Actualizar todas las traducciones del mismo grupo
        }),
      });

      const result = await response.json();
      
      console.log('üì• RESPUESTA DE API PATCH:', {
        status: response.status,
        success: result.success,
        message: result.message,
        updatedCopiesCount: result.updatedCopies?.length || 0,
        groupId: result.groupId,
        error: result.error
      });

      if (result.success) {
        console.log('‚úÖ Slug actualizado exitosamente');
        
        if (result.updatedCopies && result.updatedCopies.length > 0) {
          console.log('üìã COPYS ACTUALIZADOS:', result.updatedCopies.map(c => ({
            id: c._id || c.id,
            slug: c.slug,
            language: c.language,
            needsReview: c.needsSlugReview,
            groupId: c.translationGroupId
          })));
        }
        
        // Limpiar el estado de edici√≥n
        setEditingItems(prev => {
          const newState = { ...prev };
          delete newState[copyId];
          console.log('üßπ Estado de edici√≥n limpiado para:', copyId);
          return newState;
        });

        // Mostrar mensaje de √©xito
        toast({
          title: "Slug actualizado",
          description: result.message || `El slug ha sido actualizado en todos los idiomas`,
          status: "success",
          duration: 3000,
          isClosable: true,
        });

        console.log('üîÑ Refrescando lista de copys...');
        
        // Refrescar la lista para mostrar los cambios
        await fetchAutoGeneratedCopies();
        
        // Notificar a otras partes de la aplicaci√≥n sobre la actualizaci√≥n
        console.log('üì¢ Notificando actualizaci√≥n de slug a otras vistas...');
        
        // 1. Disparar evento personalizado para notificar a otros componentes
        if (typeof window !== 'undefined') {
          // Crear un evento detallado con la informaci√≥n de la actualizaci√≥n
          const copysUpdatedEvent = new CustomEvent('copysUpdated', {
            detail: {
              action: 'slugUpdate',
              updatedCopies: result.updatedCopies,
              newSlug: newSlugValue.trim(),
              oldSlug: copyToUpdate.originalSlug,
              timestamp: new Date().toISOString()
            }
          });
          
          // Disparar el evento para que otros componentes lo capturen
          window.dispatchEvent(copysUpdatedEvent);
        }
        
        // 2. Forzar una actualizaci√≥n de datos utilizando el dataService
        console.log('üîÑ Forzando actualizaci√≥n global de datos...');
        try {
          // Usar el dataService importado para forzar la actualizaci√≥n
          await dataService.refreshData();
          console.log('‚úÖ Actualizaci√≥n global de datos completada');
        } catch (error) {
          console.error('‚ùå Error al forzar la actualizaci√≥n de datos:', error);
        }
        
        console.log('‚úÖ Eventos de actualizaci√≥n enviados a todas las vistas');
        console.log('‚úÖ Lista de copys refrescada');
      } else {
        console.error('‚ùå Error en actualizaci√≥n:', result.error);
        toast({
          title: "Error al actualizar",
          description: result.error || "No se pudo actualizar el slug",
          status: "error",
          duration: 3000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('‚ùå ===== HANDLESLUGUPDATE - ERROR =====');
      console.error('Error al actualizar slug:', error);
      toast({
        title: "Error de conexi√≥n",
        description: "No se pudo conectar con el servidor",
        status: "error",
        duration: 3000,
        isClosable: true,
      });
    } finally {
      console.log('üîÑ ===== HANDLESLUGUPDATE - FIN =====');
    }
  }, [autoGeneratedCopies, currentUser, editingItems, toast, fetchAutoGeneratedCopies]);

  const startEditing = useCallback((copyId: string, currentSlug: string) => {
    setEditingItems(prev => ({
      ...prev,
      [copyId]: currentSlug
    }));
  }, []);

  const cancelEditing = useCallback((copyId: string) => {
    setEditingItems(prev => {
      const newState = {...prev};
      delete newState[copyId];
      return newState;
    });
  }, []);

  const openCopyDetails = useCallback((copy: AutoGeneratedCopy) => {
    setSelectedCopy(copy);
    onOpen();
  }, [onOpen]);

  // Efecto para cargar los datos iniciales cuando se abre la p√°gina o cambia el usuario
  useEffect(() => {
    // Solo cargar datos si hay un usuario autenticado
    if (currentUser) {
      console.log('üîó Cargando lista de copys que necesitan revisi√≥n de slug...');
      fetchAutoGeneratedCopies();
    }
  }, [currentUser, fetchAutoGeneratedCopies]);
  
  // Efecto para escuchar eventos de actualizaci√≥n de copys
  useEffect(() => {
    // Funci√≥n para refrescar datos cuando haya cambios generales en la aplicaci√≥n
    const handleCopysChange = () => {
      console.log('üì¢ Detectado evento copysUpdated, actualizando tareas de developer...');
      // Solo ejecutar si el usuario est√° autenticado para evitar p√©rdida de sesi√≥n
      if (currentUser) {
        fetchAutoGeneratedCopies();
      }
    };
    
    // Funci√≥n para manejar espec√≠ficamente la creaci√≥n de nuevos copys
    const handleNewCopy = (event: CustomEvent) => {
      console.log('üéâ Detectado evento newCopyCreated, nuevo copy creado!');
      console.log('üîß Detalles del nuevo copy:', event.detail);
      
      // Solo ejecutar si el usuario est√° autenticado
      if (currentUser) {
        // Refrescar la lista inmediatamente
        fetchAutoGeneratedCopies();
        
        // Mostrar notificaci√≥n al usuario sobre el nuevo copy
        toast({
          title: 'Nuevo copy creado',
          description: 'Se ha detectado un nuevo copy que necesita revisi√≥n de slug',
          status: 'success',
          duration: 3000,
          isClosable: true,
        });
      }
    };
    
    // Suscribirse a ambos eventos
    window.addEventListener('copysUpdated', handleCopysChange);
    window.addEventListener('newCopyCreated', handleNewCopy as EventListener);
    
    // Limpiar los listeners cuando el componente se desmonta
    return () => {
      window.removeEventListener('copysUpdated', handleCopysChange);
      window.removeEventListener('newCopyCreated', handleNewCopy as EventListener);
    };
  }, [currentUser, toast, fetchAutoGeneratedCopies]);

  // Filtrar copys solo por b√∫squeda (ya no filtramos por idioma)
  const filteredCopies = autoGeneratedCopies.filter(copy => {
    const matchesSearch = searchTerm === '' || 
      copy.text.toLowerCase().includes(searchTerm.toLowerCase()) ||
      copy.slug.toLowerCase().includes(searchTerm.toLowerCase());
    
    return matchesSearch;
  });

  if (loading) {
    return (
      <Container maxW="container.xl" py={8}>
        <Box textAlign="center">
          <Text>Cargando tareas de developer...</Text>
        </Box>
      </Container>
    );
  }

  return (
    <Container maxW="container.xl" py={8}>
      {/* Header */}
      <Flex mb={8} alignItems="center" justifyContent="space-between">
        <Box>
          <Heading size="lg" mb={2}>
            üîß Mis Tareas de Developer
          </Heading>
          <Text color="gray.600">
            Gestiona los textos que necesitan slugs m√°s descriptivos
          </Text>
        </Box>
        {/* Bot√≥n de refrescar manteniendo la sesi√≥n */}
        <IconButton
          aria-label="Refrescar lista"
          icon={<span role="img" aria-label="refresh">üîÑ</span>}
          colorScheme="blue"
          onClick={() => {
            // Verificar que el usuario sigue autenticado
            if (currentUser) {
              console.log('üîÑ Refrescando manualmente la lista de slugs...');
              fetchAutoGeneratedCopies();
              toast({
                title: 'Lista actualizada',
                description: 'Se han cargado los √∫ltimos copys que necesitan revisi√≥n',
                status: 'info',
                duration: 2000,
                isClosable: true,
              });
            } else {
              console.error('‚ùå Error: Usuario no autenticado');
              toast({
                title: 'Error',
                description: 'Debe iniciar sesi√≥n para actualizar la lista',
                status: 'error',
                duration: 2000,
                isClosable: true,
              });
            }
          }}
        />
      </Flex>

      {/* Estad√≠sticas */}
      <Grid templateColumns="repeat(auto-fit, minmax(200px, 1fr))" gap={4} mb={6}>
        <Card>
          <CardBody>
            <Stat>
              <StatLabel>Total de slugs auto-generados</StatLabel>
              <StatNumber>{stats.total}</StatNumber>
              <StatHelpText>Requieren revisi√≥n</StatHelpText>
            </Stat>
          </CardBody>
        </Card>
      </Grid>

      {/* Recomendaciones para slugs i18n */}
      <Alert status="info" mb={6}>
        <AlertIcon />
        <Box>
          <AlertTitle>üí° Recomendaciones para slugs compatibles con i18n</AlertTitle>
          <AlertDescription>
            <VStack align="start" spacing={2} mt={2}>
              <Text>‚Ä¢ <strong>Usa ingl√©s:</strong> Los slugs deben estar en ingl√©s para ser universales</Text>
              <Text>‚Ä¢ <strong>S√© descriptivo:</strong> Usa palabras que describan el contenido (ej: "welcome_message", "error_validation")</Text>
              <Text>‚Ä¢ <strong>Estructura jer√°rquica:</strong> Usa guiones bajos para agrupar (ej: "auth_login_title", "auth_login_button")</Text>
              <Text>‚Ä¢ <strong>Evita caracteres especiales:</strong> Solo letras, n√∫meros y guiones bajos</Text>
              <Text>‚Ä¢ <strong>Mant√©n consistencia:</strong> Usa el mismo patr√≥n en toda la aplicaci√≥n</Text>
            </VStack>
          </AlertDescription>
        </Box>
      </Alert>

      {/* Filtros */}
      <Flex mb={4} flexWrap={["wrap", "nowrap"]}>
        <InputGroup maxW="400px" mr={4} mb={[4, 0]}>
          <InputLeftElement pointerEvents="none">
            <SearchIcon color="gray.300" />
          </InputLeftElement>
          <Input 
            placeholder="Buscar por texto o slug"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </InputGroup>
      </Flex>

      {/* Tabla de slugs que necesitan revisi√≥n */}
      {filteredCopies.length > 0 ? (
        <Table variant="simple" mt={4}>
          <Thead>
            <Tr>
              <Th>Texto original</Th>
              <Th>Slug actual</Th>
              <Th>Sugerencia</Th>
              <Th>Idiomas</Th>
              <Th width="150px">Acciones</Th>
            </Tr>
          </Thead>
          <Tbody>
            {filteredCopies.map((copy) => (
              <Tr key={copy._id}>
                <Td maxW="250px" isTruncated>
                  <Text fontWeight="medium">
                    {copy.spanishText || copy.text}
                  </Text>
                </Td>
                <Td maxW="200px" isTruncated>
                  {editingItems[copy._id] !== undefined ? (
                    <InputGroup size="sm">
                      <Input
                        value={editingItems[copy._id]}
                        onChange={(e) => {
                          setEditingItems(prev => ({
                            ...prev,
                            [copy._id]: e.target.value
                          }));
                        }}
                        placeholder="Nuevo slug"
                      />
                    </InputGroup>
                  ) : (
                    <Text fontFamily="monospace" color="orange.500">
                      {copy.originalSlug}
                    </Text>
                  )}
                </Td>
                <Td maxW="200px" isTruncated>
                  <Text fontFamily="monospace" color="green.500">
                    {copy.suggestedSlug}
                  </Text>
                </Td>
                <Td>
                  <HStack spacing={1}>
                    {copy.affectedLanguages?.map((lang) => (
                      <Badge key={lang} colorScheme="blue" size="sm">
                        {lang}
                      </Badge>
                    ))}
                  </HStack>
                </Td>
                <Td>
                  {editingItems[copy._id] !== undefined ? (
                    <HStack spacing={2}>
                      <IconButton
                        aria-label="Guardar cambios"
                        icon={<CheckIcon />}
                        size="sm"
                        colorScheme="green"
                        onClick={() => handleSlugUpdate(copy._id)}
                      />
                      <IconButton
                        aria-label="Cancelar edici√≥n"
                        icon={<CloseIcon />}
                        size="sm"
                        colorScheme="red"
                        variant="outline"
                        onClick={() => cancelEditing(copy._id)}
                      />
                    </HStack>
                  ) : (
                    <HStack spacing={2}>
                      <Button
                        size="sm"
                        leftIcon={<EditIcon />}
                        colorScheme="blue"
                        variant="outline"
                        onClick={() => startEditing(copy._id, copy.originalSlug || '')}
                      >
                        Editar
                      </Button>
                    </HStack>
                  )}
                </Td>
              </Tr>
            ))}
          </Tbody>
        </Table>
      ) : (
        <Box textAlign="center" p={8} borderWidth="1px" borderRadius="lg">
          <Heading size="md" mb={2} color="gray.500">No hay slugs por revisar</Heading>
          <Text>Todos los slugs han sido revisados o a√∫n no se han creado copys que requieran revisi√≥n.</Text>
        </Box>
      )}

      {/* Modal de detalles del copy */}
      <Modal isOpen={isOpen} onClose={onClose} size="xl">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Detalles del Copy</ModalHeader>
          <ModalCloseButton />
          <ModalBody>
            {selectedCopy && (
              <Box>
                <Heading size="sm" mb={2}>Texto Original</Heading>
                <Text mb={4}>{selectedCopy.text}</Text>
                
                <Heading size="sm" mb={2}>Slug Actual</Heading>
                <Text fontFamily="monospace" mb={4}>{selectedCopy.originalSlug}</Text>
                
                <Heading size="sm" mb={2}>Slug Sugerido</Heading>
                <Text fontFamily="monospace" color="green.500" mb={4}>{selectedCopy.suggestedSlug}</Text>
                
                <Heading size="sm" mb={2}>Idiomas Afectados</Heading>
                <HStack spacing={2} mb={4}>
                  {selectedCopy.affectedLanguages?.map(lang => (
                    <Badge key={lang} colorScheme="blue">{lang}</Badge>
                  ))}
                </HStack>
                
                <Heading size="sm" mb={2}>ID Original</Heading>
                <Text fontFamily="monospace" fontSize="sm" mb={4}>{selectedCopy._id}</Text>
              </Box>
            )}
          </ModalBody>
          <ModalFooter>
            <Button variant="ghost" mr={3} onClick={onClose}>
              Cerrar
            </Button>
            {selectedCopy && (
              <Button 
                colorScheme="blue" 
                onClick={() => {
                  onClose();
                  startEditing(selectedCopy._id, selectedCopy.originalSlug || '');
                }}
              >
                Editar Slug
              </Button>
            )}
          </ModalFooter>
        </ModalContent>
      </Modal>
    </Container>
  );
}
